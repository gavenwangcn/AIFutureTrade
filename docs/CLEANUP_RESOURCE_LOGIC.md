# 清理资源代码处理逻辑详解

## 问题分析

在测试中发现清理资源时卡住不动，经过分析发现以下问题：

### 1. **无限递归问题**
- `_cleanup_broken_connections()` 方法在第1341行调用了自己，导致无限递归
- 这会导致栈溢出和程序卡死

### 2. **在持有锁的情况下调用阻塞操作**
- `cleanup_expired_connections()` 在持有锁的情况下调用 `await conn.close()`
- `conn.close()` 可能会阻塞（等待WebSocket关闭），导致其他需要锁的操作被阻塞
- 这会导致整个程序卡住

### 3. **方法实现错误**
- `cleanup_all()` 方法应该清理所有连接，但实际上只是返回连接列表
- `get_connection_count()` 的文档字符串说的是"清理过期的连接"，但实际是获取连接数
- `get_connection_list()` 没有持有锁，直接访问 `self._active_connections`

## 修复后的清理资源代码逻辑

### 1. `cleanup_expired_connections()` - 清理过期连接

**处理逻辑：**
```
1. 在持有锁的情况下，遍历所有连接，找出已过期的连接（创建时间超过24小时）
2. 收集过期连接的key和conn对象到列表中
3. 在锁内从字典中删除这些连接
4. 释放锁
5. 在锁外逐个关闭连接（避免阻塞）
6. 为每个关闭操作添加5秒超时保护，避免卡住
```

**关键改进：**
- ✅ 不在持有锁的情况下调用 `conn.close()`
- ✅ 添加超时保护，避免关闭连接时卡住
- ✅ 即使关闭失败也不会影响其他连接的清理

### 2. `_cleanup_broken_connections()` - 清理断开的连接

**处理逻辑：**
```
1. 在持有锁的情况下，遍历所有连接，找出不活跃的连接（is_active=False）
2. 收集断开连接的key到列表中
3. 释放锁
4. 在锁外逐个关闭连接（避免阻塞）
5. 为每个关闭操作添加异常处理
6. 再次获取锁，从字典中删除已关闭的连接
```

**关键改进：**
- ✅ 修复了无限递归问题（移除了对自己的调用）
- ✅ 不在持有锁的情况下调用 `conn.close()`
- ✅ 添加异常处理，确保即使关闭失败也能继续清理其他连接

### 3. `cleanup_all()` - 清理所有连接

**处理逻辑：**
```
1. 标记为正在关闭（self._is_closing = True）
2. 取消后台任务（_check_task 和 _ping_task）
3. 在持有锁的情况下，收集所有连接并清空字典
4. 释放锁
5. 在锁外逐个关闭所有连接（避免阻塞）
6. 为每个关闭操作添加5秒超时保护
7. 记录详细的清理日志
```

**关键改进：**
- ✅ 正确实现了清理所有连接的功能
- ✅ 不在持有锁的情况下调用 `conn.close()`
- ✅ 添加超时保护，避免关闭连接时卡住
- ✅ 取消后台任务，避免任务继续运行

### 4. `get_connection_count()` - 获取连接数

**处理逻辑：**
```
1. 在持有锁的情况下，返回连接字典的长度
```

**关键改进：**
- ✅ 修复了文档字符串，现在正确描述为"获取当前连接数"
- ✅ 简化实现，只获取连接数，不进行清理操作

### 5. `get_connection_list()` - 获取连接列表

**处理逻辑：**
```
1. 在持有锁的情况下，遍历所有连接
2. 构建连接信息列表并返回
```

**关键改进：**
- ✅ 修复了文档字符串，现在正确描述为"获取当前所有连接的详细信息"
- ✅ 确保在持有锁的情况下访问 `self._active_connections`

### 6. `get_connection_status()` - 获取连接状态

**处理逻辑：**
```
1. 在锁外调用 cleanup_expired_connections() 和 _cleanup_broken_connections()
2. 在持有锁的情况下，计算连接数和symbol列表
3. 返回状态信息
```

**关键改进：**
- ✅ 在锁外执行清理操作，避免阻塞
- ✅ 确保在持有锁的情况下访问 `self._active_connections`

### 7. `get_symbols()` - 获取symbol列表

**处理逻辑：**
```
1. 在锁外调用 cleanup_expired_connections()
2. 在持有锁的情况下，收集所有唯一的symbol并返回
```

**关键改进：**
- ✅ 在锁外执行清理操作，避免阻塞

## 关键设计原则

### 1. **避免在持有锁的情况下调用阻塞操作**
- 所有可能阻塞的操作（如 `conn.close()`）都在锁外执行
- 先收集需要操作的对象，释放锁，然后执行操作

### 2. **添加超时保护**
- 所有关闭连接的操作都添加了5秒超时保护
- 避免因为网络问题或SDK问题导致程序卡住

### 3. **异常处理**
- 所有关闭操作都添加了异常处理
- 即使某个连接关闭失败，也不会影响其他连接的清理

### 4. **详细的日志记录**
- 记录每个清理步骤的详细信息
- 便于排查问题和监控清理进度

## 使用示例

```python
# 清理所有连接
await kline_manager.cleanup_all()

# 清理过期连接
await kline_manager.cleanup_expired_connections()

# 清理断开的连接
await kline_manager._cleanup_broken_connections()

# 获取连接数
count = await kline_manager.get_connection_count()

# 获取连接列表
connections = await kline_manager.get_connection_list()

# 获取连接状态
status = await kline_manager.get_connection_status()
```

## 注意事项

1. **不要在持有锁的情况下调用可能阻塞的操作**
   - 这会导致其他需要锁的操作被阻塞
   - 可能导致整个程序卡住

2. **为所有网络操作添加超时保护**
   - WebSocket关闭操作可能会因为网络问题而卡住
   - 超时保护可以避免程序无限等待

3. **确保异常处理完善**
   - 即使某个操作失败，也不应该影响其他操作
   - 应该记录详细的错误日志

4. **避免无限递归**
   - 方法不应该调用自己（除非有明确的终止条件）
   - 无限递归会导致栈溢出和程序卡死

